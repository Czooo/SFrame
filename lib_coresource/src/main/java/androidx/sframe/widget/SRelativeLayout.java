package androidx.sframe.widget;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.util.SparseArray;
import android.view.View;
import android.view.ViewGroup;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.customview.view.AbsSavedState;
import androidx.demon.widget.DragRelativeLayout;
import androidx.sframe.R;
import androidx.sframe.ui.controller.UILayoutController;
import androidx.sframe.ui.controller.UIToolbarController;
import androidx.sframe.ui.controller.UIViewController;
import androidx.sframe.ui.controller.impl.UILayout;
import androidx.sframe.ui.controller.impl.UILayoutControllerImpl;

/**
 * @Author create by Zoran on 2019-09-18
 * @Email : 171905184@qq.com
 * @Description :
 */
public class SRelativeLayout extends DragRelativeLayout {

	private UILayoutController mLayoutController;

	public SRelativeLayout(Context context) {
		this(context, null);
	}

	public SRelativeLayout(Context context, AttributeSet attrs) {
		this(context, attrs, 0);
	}

	public SRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) {
		super(context, attrs, defStyleAttr);
		final TypedArray mTypedArray = context.obtainStyledAttributes(attrs, R.styleable.SRelativeLayout);
		this.getLayoutController()
				.setShouldRunWithAsync(mTypedArray.getBoolean(R.styleable.SRelativeLayout_layoutRunWithAsync, false))
				.setShouldAutoLayoutMode(mTypedArray.getBoolean(R.styleable.SRelativeLayout_layoutAutoMode, true))
				.layoutAt(mTypedArray.getInteger(R.styleable.SRelativeLayout_layoutPreKey, UILayoutController.LayoutType.None.key));
		mTypedArray.recycle();
	}

	/**
	 * Adds a child view with the specified layout parameters.
	 *
	 * <p><strong>Note:</strong> do not invoke this method from
	 * {@link #draw(Canvas)}, {@link #onDraw(Canvas)},
	 * {@link #dispatchDraw(Canvas)} or any related method.</p>
	 *
	 * @param child  the child view to add
	 * @param index  the position at which to add the child or -1 to add last
	 * @param params the layout parameters to set on the child
	 */
	@Override
	public void addView(View child, int index, ViewGroup.LayoutParams params) {
		LayoutParams layoutParams;
		if (params == null) {
			layoutParams = this.generateDefaultLayoutParams();
		} else if (!this.checkLayoutParams(params)) {
			layoutParams = this.generateLayoutParams(params);
		} else {
			layoutParams = (LayoutParams) params;
		}
		if (UILayoutController.LayoutType.None.key == layoutParams.layoutKey) {
			this.addViewInternal(child, index, params);
		} else {
			this.getLayoutController().addLayoutInternal(layoutParams.builder()
					.setLayoutSpareId(child.getId())
					.setContentView(child)
					.build(), index, layoutParams);
		}
	}

	/**
	 * Hook allowing a view to generate a representation of its internal state
	 * that can later be used to create a new instance with that same state.
	 * This state should only contain information that is not persistent or can
	 * not be reconstructed later. For example, you will never store your
	 * current position on screen because that will be computed again when a
	 * new instance of the view is placed in its view hierarchy.
	 * <p>
	 * Some examples of things you may store here: the current cursor position
	 * in a text view (but usually not the text itself since that is stored in a
	 * content provider or other persistent storage), the currently selected
	 * item in a list view.
	 *
	 * @return Returns a Parcelable object containing the view's current dynamic
	 * state, or null if there is nothing interesting to save.
	 * @see #onRestoreInstanceState(Parcelable)
	 * @see #saveHierarchyState(SparseArray)
	 * @see #dispatchSaveInstanceState(SparseArray)
	 * @see #setSaveEnabled(boolean)
	 */
	@Nullable
	@Override
	protected Parcelable onSaveInstanceState() {
		final Parcelable superState = super.onSaveInstanceState();
		final SavedState savedState = new SavedState(superState);
		final Bundle savedInstanceState = new Bundle();
		if (this.mLayoutController != null) {
			this.mLayoutController.onSaveInstanceState(savedInstanceState);
		}
		savedState.savedInstanceState = savedInstanceState;
		return savedState;
	}

	/**
	 * Hook allowing a view to re-apply a representation of its internal state that had previously
	 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
	 * null state.
	 *
	 * @param state The frozen state that had previously been returned by
	 *              {@link #onSaveInstanceState}.
	 * @see #onSaveInstanceState()
	 * @see #restoreHierarchyState(SparseArray)
	 * @see #dispatchRestoreInstanceState(SparseArray)
	 */
	@Override
	protected void onRestoreInstanceState(Parcelable state) {
		if (state instanceof SavedState) {
			SavedState savedState = (SavedState) state;
			super.onRestoreInstanceState(savedState.getSuperState());
			if (this.mLayoutController != null) {
				this.mLayoutController.onRestoreInstanceState(savedState.savedInstanceState);
			}
			return;
		}
		super.onRestoreInstanceState(state);
	}

	/**
	 * Returns a set of layout parameters with a width of
	 * {@link ViewGroup.LayoutParams#WRAP_CONTENT},
	 * a height of {@link ViewGroup.LayoutParams#WRAP_CONTENT} and no spanning.
	 */
	@Override
	protected LayoutParams generateDefaultLayoutParams() {
		return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
	}

	@Override
	protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams layoutParams) {
		return new LayoutParams(layoutParams);
	}

	@Override
	public LayoutParams generateLayoutParams(AttributeSet attrs) {
		return new LayoutParams(this.getContext(), attrs);
	}

	@Override
	protected boolean checkLayoutParams(ViewGroup.LayoutParams layoutParams) {
		return layoutParams instanceof LayoutParams;
	}

	@NonNull
	public final UIViewController getViewController() {
		return this.getLayoutController().getViewController();
	}

	@NonNull
	public final UIToolbarController getToolbarController() {
		return this.getLayoutController().getToolbarController();
	}

	@NonNull
	public UILayoutController getLayoutController() {
		if (this.mLayoutController == null) {
			this.mLayoutController = new UILayoutControllerImpl(this);
		}
		return this.mLayoutController;
	}

	public final void addViewInternal(@NonNull View child, int index, @Nullable ViewGroup.LayoutParams layoutParams) {
		if (layoutParams == null) {
			layoutParams = this.generateDefaultLayoutParams();
		} else if (!(this.checkLayoutParams(layoutParams))) {
			layoutParams = this.generateLayoutParams(layoutParams);
		}
		super.addView(child, index, layoutParams);
	}

	public static class LayoutParams extends DragRelativeLayout.LayoutParams {

		private int layoutKey = UILayout.NO_KEY;
		private int layoutEnterAnimation = 0;
		private int layoutExitAnimation = 0;
		private boolean mIsLayoutEnabled = true;
		private boolean mIsLayoutStableMode = true;

		public LayoutParams(int width, int height) {
			super(width, height);
		}

		/**
		 * Copy constructor. Clones the width, height, margin values, and rules
		 * of the source.
		 *
		 * @param source The layout params to copy from.
		 */
		public LayoutParams(LayoutParams source) {
			super(source);
			this.layoutKey = source.layoutKey;
			this.layoutEnterAnimation = source.layoutEnterAnimation;
			this.layoutExitAnimation = source.layoutExitAnimation;
			this.mIsLayoutEnabled = source.mIsLayoutEnabled;
			this.mIsLayoutStableMode = source.mIsLayoutStableMode;
		}

		/**
		 * {@inheritDoc}
		 *
		 * @param source
		 */
		public LayoutParams(ViewGroup.LayoutParams source) {
			super(source);
		}

		public LayoutParams(Context context, AttributeSet attrs) {
			super(context, attrs);
			final TypedArray mTypedArray = context.obtainStyledAttributes(attrs, R.styleable.SRelativeLayout_Layout);
			this.layoutKey = mTypedArray.getInteger(R.styleable.SRelativeLayout_Layout_layoutKey, this.layoutKey);
			this.layoutEnterAnimation = mTypedArray.getResourceId(R.styleable.SRelativeLayout_Layout_layoutEnterAnimation, this.layoutEnterAnimation);
			this.layoutExitAnimation = mTypedArray.getResourceId(R.styleable.SRelativeLayout_Layout_layoutExitAnimation, this.layoutExitAnimation);
			this.mIsLayoutStableMode = mTypedArray.getBoolean(R.styleable.SRelativeLayout_Layout_layoutStableMode, this.mIsLayoutStableMode);
			mTypedArray.recycle();
		}

		@NonNull
		private UILayout.Builder builder() {
			return new UILayout.Builder(this.layoutKey)
					.setLayoutEnabled(this.mIsLayoutEnabled)
					.setLayoutStableMode(this.mIsLayoutStableMode)
					.setLayoutEnterAnimation(this.layoutEnterAnimation)
					.setLayoutExitAnimation(this.layoutExitAnimation);
		}
	}

	public static class SavedState extends AbsSavedState {

		private Parcelable mSuperState;
		private Bundle savedInstanceState;

		SavedState(Parcelable superState) {
			super(superState);
			this.mSuperState = superState;
		}

		SavedState(Parcel source, ClassLoader loader) {
			super(source, loader);
			if (loader == null) {
				loader = getClass().getClassLoader();
			}
			this.mSuperState = source.readParcelable(loader);
			this.savedInstanceState = source.readBundle(loader);
		}

		@Override
		public void writeToParcel(Parcel dest, int flags) {
			super.writeToParcel(dest, flags);
			dest.writeParcelable(this.mSuperState, flags);
			dest.writeBundle(this.savedInstanceState);
		}

		public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.ClassLoaderCreator<SavedState>() {

			@Override
			public SavedState createFromParcel(Parcel in) {
				return new SavedState(in, null);
			}

			@Override
			public SavedState createFromParcel(Parcel source, ClassLoader loader) {
				return new SavedState(source, loader);
			}

			@Override
			public SavedState[] newArray(int size) {
				return new SavedState[size];
			}
		};
	}
}
